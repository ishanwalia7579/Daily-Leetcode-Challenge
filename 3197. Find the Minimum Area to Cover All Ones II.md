3197. Find the Minimum Area to Cover All Ones II
Hard
Topics
premium lock icon
Companies
Hint
You are given a 2D binary array grid. You need to find 3 non-overlapping rectangles having non-zero areas with horizontal and vertical sides such that all the 1's in grid lie inside these rectangles.

Return the minimum possible sum of the area of these rectangles.

Note that the rectangles are allowed to touch.

 

Example 1:

Input: grid = [[1,0,1],[1,1,1]]

Output: 5

Explanation:



The 1's at (0, 0) and (1, 0) are covered by a rectangle of area 2.
The 1's at (0, 2) and (1, 2) are covered by a rectangle of area 2.
The 1 at (1, 1) is covered by a rectangle of area 1.
Example 2:

Input: grid = [[1,0,1,0],[0,1,0,1]]

Output: 5

Explanation:



The 1's at (0, 0) and (0, 2) are covered by a rectangle of area 3.
The 1 at (1, 1) is covered by a rectangle of area 1.
The 1 at (1, 3) is covered by a rectangle of area 1.
 

Constraints:

1 <= grid.length, grid[i].length <= 30
grid[i][j] is either 0 or 1.
The input is generated such that there are at least three 1's in grid.


```java



class Solution {
  public int minimumSum(int[][] grid) {
    final int m = grid.length;     // Rows
    final int n = grid[0].length;  // Columns
    int ans = m * n;  // Start with max possible area (upper bound)

    // ðŸ”¹ Case 1: Split into 3 parts -> top + left + right
    for (int i = 0; i < m; ++i) {
      // top rectangle from row 0 to i
      final int top = minimumArea(grid, 0, i, 0, n - 1);
      for (int j = 0; j < n; ++j)
        // left rectangle + right rectangle below top
        ans = Math.min(ans,
            top +
            /* left rectangle */ minimumArea(grid, i + 1, m - 1, 0, j) +
            /* right rectangle */ minimumArea(grid, i + 1, m - 1, j + 1, n - 1));
    }

    // ðŸ”¹ Case 2: Split into 3 parts -> bottom + left + right
    for (int i = 0; i < m; ++i) {
      // bottom rectangle from row i to last
      final int bottom = minimumArea(grid, i, m - 1, 0, n - 1);
      for (int j = 0; j < n; ++j)
        ans = Math.min(ans,
            bottom +
            /* left rectangle */ minimumArea(grid, 0, i - 1, 0, j) +
            /* right rectangle */ minimumArea(grid, 0, i - 1, j + 1, n - 1));
    }

    // ðŸ”¹ Case 3: Split into 3 parts -> left + top + bottom
    for (int j = 0; j < n; ++j) {
      // left rectangle from col 0 to j
      final int left = minimumArea(grid, 0, m - 1, 0, j);
      for (int i = 0; i < m; ++i)
        ans = Math.min(ans,
            left +
            /* top rectangle */ minimumArea(grid, 0, i, j + 1, n - 1) +
            /* bottom rectangle */ minimumArea(grid, i + 1, m - 1, j + 1, n - 1));
    }

    // ðŸ”¹ Case 4: Split into 3 parts -> right + top + bottom
    for (int j = 0; j < n; ++j) {
      // right rectangle from col j to last
      final int right = minimumArea(grid, 0, m - 1, j, n - 1);
      for (int i = 0; i < m; ++i)
        ans = Math.min(ans,
            right +
            /* top rectangle */ minimumArea(grid, 0, i, 0, j - 1) +
            /* bottom rectangle */ minimumArea(grid, i + 1, m - 1, 0, j - 1));
    }

    // ðŸ”¹ Case 5: Horizontal 3-split (top, middle, bottom)
    for (int i1 = 0; i1 < m; ++i1)
      for (int i2 = i1 + 1; i2 < m; ++i2)
        ans = Math.min(ans,
            /* top rectangle */ minimumArea(grid, 0, i1, 0, n - 1) +
            /* middle rectangle */ minimumArea(grid, i1 + 1, i2, 0, n - 1) +
            /* bottom rectangle */ minimumArea(grid, i2 + 1, m - 1, 0, n - 1));

    // ðŸ”¹ Case 6: Vertical 3-split (left, middle, right)
    for (int j1 = 0; j1 < n; ++j1)
      for (int j2 = j1 + 1; j2 < n; ++j2)
        ans = Math.min(ans,
            /* left rectangle */ minimumArea(grid, 0, m - 1, 0, j1) +
            /* middle rectangle */ minimumArea(grid, 0, m - 1, j1 + 1, j2) +
            /* right rectangle */ minimumArea(grid, 0, m - 1, j2 + 1, n - 1));

    return ans;
  }

  // âœ… Helper function: finds minimum bounding rectangle area containing all 1s in subgrid
  private int minimumArea(int[][] grid, int si, int ei, int sj, int ej) {
    int x1 = Integer.MAX_VALUE; // min row index where 1 is found
    int y1 = Integer.MAX_VALUE; // min col index where 1 is found
    int x2 = 0; // max row index where 1 is found
    int y2 = 0; // max col index where 1 is found

    // Traverse subgrid and find bounding rectangle of 1s
    for (int i = si; i <= ei; ++i)
      for (int j = sj; j <= ej; ++j)
        if (grid[i][j] == 1) {
          x1 = Math.min(x1, i);
          y1 = Math.min(y1, j);
          x2 = Math.max(x2, i);
          y2 = Math.max(y2, j);
        }

    // If no 1 found, return 0
    return x1 == Integer.MAX_VALUE ? 0 : (x2 - x1 + 1) * (y2 - y1 + 1);
  }
}




````
