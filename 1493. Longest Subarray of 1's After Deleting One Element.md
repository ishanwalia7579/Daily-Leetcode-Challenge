
Code
Testcase
Testcase
Test Result
1493. Longest Subarray of 1's After Deleting One Element
Medium
Topics
premium lock icon
Companies
Hint
Given a binary array nums, you should delete one element from it.

Return the size of the longest non-empty subarray containing only 1's in the resulting array. Return 0 if there is no such subarray.

 

Example 1:

Input: nums = [1,1,0,1]
Output: 3
Explanation: After deleting the number in position 2, [1,1,1] contains 3 numbers with value of 1's.
Example 2:

Input: nums = [0,1,1,1,0,1,1,0,1]
Output: 5
Explanation: After deleting the number in position 4, [0,1,1,1,1,1,0,1] longest subarray with value of 1's is [1,1,1,1,1].
Example 3:

Input: nums = [1,1,1]
Output: 2
Explanation: You must delete one element.
 

Constraints:

1 <= nums.length <= 105
nums[i] is either 0 or 1.


```


class Solution {
    public int longestSubarray(int[] nums) {
        int left = 0;
        int zeroCount = 0;
        int maxLength = 0;

        for (int right = 0; right < nums.length; right++) {
            if (nums[right] == 0) {
                zeroCount++;
            }

            // Shrink the window if there are more than one zero
            while (zeroCount > 1) {
                if (nums[left] == 0) {
                    zeroCount--;
                }
                left++;
            }

            // Calculate the current subarray length (excluding the deleted element)
            // If the entire array consists of 1s, we must delete one, so the length is right - left.
            // If there's at least one zero in the window, we've effectively deleted one,
            // so the length is (right - left).
            maxLength = Math.max(maxLength, right - left);
        }

        // Edge case: If the array contains only 1s, we must delete one,
        // so the result should be nums.length - 1.
        // The loop above already handles this implicitly if maxLength is calculated as right - left.
        // However, if the array is all 1s, zeroCount will remain 0, and right - left will be nums.length - 1.
        // If the array is all 1s and has length 1, maxLength will be 0, which is correct (delete the 1, no 1s left).
        // If the array is all 1s and has length > 1, maxLength will be nums.length - 1.
        // So, the final return should handle the case where no 0 was encountered, meaning a 1 must be deleted.
        if (maxLength == nums.length) { // This means the original array had no zeros
            return nums.length - 1;
        }

        return maxLength;
    }
}

```
